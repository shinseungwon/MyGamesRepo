0	00	00000000	&#0;	NUL	Null
1	01	00000001	&#1;	SOH	Start of Header
2	02	00000010	&#2;	STX	Start of Text
3	03	00000011	&#3;	ETX	End of Text
4	04	00000100	&#4;	EOT	End of Transmission
5	05	00000101	&#5;	ENQ	Enquiry
6	06	00000110	&#6;	ACK	Acknowledge
7	07	00000111	&#7;	BEL	Bell
8	08	00001000	&#8;	BS	Backspace
9	09	00001001	&#9;	HT	Horizontal Tab
10	0A	00001010	&#10;	LF	Line Feed
11	0B	00001011	&#11;	VT	Vertical Tab
12	0C	00001100	&#12;	FF	Form Feed
13	0D	00001101	&#13;	CR	Carriage Return
14	0E	00001110	&#14;	SO	Shift Out
15	0F	00001111	&#15;	SI	Shift In
16	10	00010000	&#16;	DLE	Data Link Escape
17	11	00010001	&#17;	DC1	Device Control 1
18	12	00010010	&#18;	DC2	Device Control 2
19	13	00010011	&#19;	DC3	Device Control 3
20	14	00010100	&#20;	DC4	Device Control 4
21	15	00010101	&#21;	NAK	Negative Acknowledge
22	16	00010110	&#22;	SYN	Synchronize
23	17	00010111	&#23;	ETB	End of Transmission Block
24	18	00011000	&#24;	CAN	Cancel
25	19	00011001	&#25;	EM	End of Medium
26	1A	00011010	&#26;	SUB	Substitute
27	1B	00011011	&#27;	ESC	Escape
28	1C	00011100	&#28;	FS	File Separator
29	1D	00011101	&#29;	GS	Group Separator
30	1E	00011110	&#30;	RS	Record Separator
31	1F	00011111	&#31;	US	Unit Separator
32	20	00100000	&#32;	space	Space
33	21	00100001	&#33;	!	Exclamation mark
34	22	00100010	&#34;	"	Double quote
35	23	00100011	&#35;	#	Number
36	24	00100100	&#36;	$	Dollar sign
37	25	00100101	&#37;	%	Percent
38	26	00100110	&#38;	&	Ampersand
39	27	00100111	&#39;	'	Single quote
40	28	00101000	&#40;	(	Left parenthesis
41	29	00101001	&#41;	)	Right parenthesis
42	2A	00101010	&#42;	*	Asterisk
43	2B	00101011	&#43;	+	Plus
44	2C	00101100	&#44;	,	Comma
45	2D	00101101	&#45;	-	Minus
46	2E	00101110	&#46;	.	Period
47	2F	00101111	&#47;	/	Slash
48	30	00110000	&#48;	0	Zero
49	31	00110001	&#49;	1	One
50	32	00110010	&#50;	2	Two
51	33	00110011	&#51;	3	Three
52	34	00110100	&#52;	4	Four
53	35	00110101	&#53;	5	Five
54	36	00110110	&#54;	6	Six
55	37	00110111	&#55;	7	Seven
56	38	00111000	&#56;	8	Eight
57	39	00111001	&#57;	9	Nine
58	3A	00111010	&#58;	:	Colon
59	3B	00111011	&#59;	;	Semicolon
60	3C	00111100	&#60;	<	Less than
61	3D	00111101	&#61;	=	Equality sign
62	3E	00111110	&#62;	>	Greater than
63	3F	00111111	&#63;	?	Question mark
64	40	01000000	&#64;	@	At sign
65	41	01000001	&#65;	A	Capital A
66	42	01000010	&#66;	B	Capital B
67	43	01000011	&#67;	C	Capital C
68	44	01000100	&#68;	D	Capital D
69	45	01000101	&#69;	E	Capital E
70	46	01000110	&#70;	F	Capital F
71	47	01000111	&#71;	G	Capital G
72	48	01001000	&#72;	H	Capital H
73	49	01001001	&#73;	I	Capital I
74	4A	01001010	&#74;	J	Capital J
75	4B	01001011	&#75;	K	Capital K
76	4C	01001100	&#76;	L	Capital L
77	4D	01001101	&#77;	M	Capital M
78	4E	01001110	&#78;	N	Capital N
79	4F	01001111	&#79;	O	Capital O
80	50	01010000	&#80;	P	Capital P
81	51	01010001	&#81;	Q	Capital Q
82	52	01010010	&#82;	R	Capital R
83	53	01010011	&#83;	S	Capital S
84	54	01010100	&#84;	T	Capital T
85	55	01010101	&#85;	U	Capital U
86	56	01010110	&#86;	V	Capital V
87	57	01010111	&#87;	W	Capital W
88	58	01011000	&#88;	X	Capital X
89	59	01011001	&#89;	Y	Capital Y
90	5A	01011010	&#90;	Z	Capital Z
91	5B	01011011	&#91;	[	Left square bracket
92	5C	01011100	&#92;	\	Backslash
93	5D	01011101	&#93;	]	Right square bracket
94	5E	01011110	&#94;	^	Caret / circumflex
95	5F	01011111	&#95;	_	Underscore
96	60	01100000	&#96;	`	Grave / accent
97	61	01100001	&#97;	a	Small a
98	62	01100010	&#98;	b	Small b
99	63	01100011	&#99;	c	Small c
100	64	01100100	&#100;	d	Small d
101	65	01100101	&#101;	e	Small e
102	66	01100110	&#102;	f	Small f
103	67	01100111	&#103;	g	Small g
104	68	01101000	&#104;	h	Small h
105	69	01101001	&#105;	i	Small i
106	6A	01101010	&#106;	j	Small j
107	6B	01101011	&#107;	k	Small k
108	6C	01101100	&#108;	l	Small l
109	6D	01101101	&#109;	m	Small m
110	6E	01101110	&#110;	n	Small n
111	6F	01101111	&#111;	o	Small o
112	70	01110000	&#112;	p	Small p
113	71	01110001	&#113;	q	Small q
114	72	01110010	&#114;	r	Small r
115	73	01110011	&#115;	s	Small s
116	74	01110100	&#116;	t	Small t
117	75	01110101	&#117;	u	Small u
118	76	01110110	&#118;	v	Small v
119	77	01110111	&#119;	w	Small w
120	78	01111000	&#120;	x	Small x
121	79	01111001	&#121;	y	Small y
122	7A	01111010	&#122;	z	Small z
123	7B	01111011	&#123;	{	Left curly bracket
124	7C	01111100	&#124;	|	Vertical bar
125	7D	01111101	&#125;	}	Right curly bracket
126	7E	01111110	&#126;	~	Tilde
127	7F	01111111	&#127;	DEL	Delete







void Run(promise<string>* p) {
	HDC hdc = GetDC(hWnd);

	COLORREF* arr = (COLORREF*)calloc(512 * 512, sizeof(COLORREF));
	HDC src = CreateCompatibleDC(hdc);
	HBITMAP map;
	//LPCWSTR path = TEXT("C:\\Users\\ssw90\\source\\repos\\MyGamesRepo\\GameEngine\\Debug\\test.bmp");
	//LPCWSTR path = TEXT("C:\\Download\\test3.bmp");	
	LPCWSTR path = TEXT("bmps\\test.bmp");
	
	map = (HBITMAP)LoadImage(GetModuleHandle(NULL), path, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
	
	
	//SelectObject(src, map);
	//BitBlt(hdc, 10, 10, 512, 512, src, 0, 0, SRCCOPY);

	//return;
	int r = 0, g = 0, b = 0;
	int x = 0, y = 0, z = 0;
	while (1) {

		//Sleep(1000);
		//for (int i = 0; i < 512; i++) {
		//	for (int j = 0; j < 512; j++) {				
		//		x = (i + j + r) % 256;
		//		y = (i + j + b) % 256;
		//		z = (i + j + b) % 256;
		//		arr[i* 512 + j] = RGB(x, y, z);
		//	}
		//}
		//map = CreateBitmap(512, 512, 1, 8 * 4, (void*)arr);

		SelectObject(src, map);
		BitBlt(hdc, 10 + r, 10 + g, 512, 512, src, 0, 0, SRCCOPY);
		r++;
		g++;
		b++;
		cout << "Drawing ..." << r << ' ' << g << ' ' << b << endl;
		Sleep(10);
	}

	DeleteDC(src);
	ReleaseDC(hWnd, hdc);
	p->set_value("End");
}

	ifstream ifstr("bmps\\test1.bmp", ios::binary);

	if (ifstr.is_open()) {
		vector<char> vc(istreambuf_iterator<char>(ifstr), (istreambuf_iterator<char>()));
		for (int i = 0; i < vc.size(); i++) {
			cout << vc[i] << ' ';
		}
		cout << endl;		
	}
	else {
		cout << "x" << endl;
	}
	
						//cout << (int)(unsigned char)vc[i] << ' ';
					//if (vc[i] == 0x00) {
					//	cout << ' ';
					//}
					//else {
					//	cout << 'X';
					//}

					//cout << (int)(unsigned char)vc[i] << ' ' << (int)(unsigned char)vc[i + 1] << ' ' << (int)(unsigned char)vc[i + 2] << endl;
					//if (vc[i] != 0x00 || vc[i + 1] != 0x00 || vc[i + 2] != 0x00) {
					//	cout << 'X';
					//}
					//else {
					//	cout << ' ';
					//}

					//if ((i - headerSize + 1) % (36 * 3) == 1) {
					//	cout << endl;
					//}
					
					//class BitmapPack {
//public:
//	COLORREF* data;
//	int size;
//	int width;
//	int height;
//};

//BitmapPack* GetBitmap(string path) {
//	BitmapPack* res = new BitmapPack();
//	int i = 0, j = 0;
//	char* arr = nullptr;
//
//	ifstream ifstr(path, ios::binary);
//
//	if (ifstr.is_open()) {
//		vector<char> vc(istreambuf_iterator<char>(ifstr), (istreambuf_iterator<char>()));
//		if (vc[0] == 0x42 && vc[1] == 0x4D) {
//
//			int headerSize;
//			int width;
//			int height;
//			short bitCount;
//
//			memcpy(&headerSize, &vc[10], sizeof(int));
//			memcpy(&width, &vc[18], sizeof(int));
//			memcpy(&height, &vc[22], sizeof(int));
//			memcpy(&bitCount, &vc[28], sizeof(short));
//
//			int resultSize = (vc.size() - headerSize) / 3 * 4;
//			arr = new char[resultSize];
//
//			if (bitCount == 24) {
//				for (i = headerSize; i < vc.size(); i += 3) {
//					arr[j++] = vc[i];
//					arr[j++] = vc[i + 1];
//					arr[j++] = vc[i + 2];
//					arr[j++] = char(0);
//				}
//
//				res->size = resultSize / 4;
//				res->width = width;
//				res->height = height;
//				res->data = (COLORREF*)arr;
//			}
//			else {
//				cout << "file is not 24bit bitmap" << endl;
//			}
//		}
//		else {
//			cout << "file is not bitmap" << endl;
//		}
//
//		ifstr.close();
//	}
//	else {
//		cout << "file not exist" << endl;
//	}
//
//	return res;
//}

	//HBITMAP hBitmap = (HBITMAP)LoadImage(GetModuleHandle(NULL), path, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
	//BITMAP bitmap;
	//GetObject(hBitmap, sizeof(BITMAP), &bitmap);

	//PlaySound(TEXT("wavs\\test1.wav"), 0, SND_FILENAME | SND_ASYNC);

	https://stackoverflow.com/questions/38597898/win32-playsound-overlapping-audio

	void GObject::AddShape(COLORREF* shape, int width, int height) {
	if (this->width == 0) {
		this->width = width;
	}
	if (this->height == 0) {
		this->height = height;
	}
	shapes->push_back(shape);
}

void GObject::AddShape(string path) {
	BitmapPack* pack = GetBitmap(path);
	AddShape(pack->data, pack->width, pack->height);
}

MCI_PLAY_PARMS mciPlay; //파일을 재생
MCI_STATUS_PARMS mciStatus; //파일의 상태
	wDeviceID = mciOpen.wDeviceID;

		//mciSendString(TEXT("open \"wavs\\test2.mp3\" type mpegvideo alias mp3"), NULL, 0, NULL);
	//mciSendString(TEXT("play mp3 from 100000"), NULL, 0, NULL);
	//Sleep(2000);
	//mciSendString(TEXT("play mp3"), NULL, 0, NULL);

	//DWORD Sound1, Sound2;
	//Sound1 = LoadWAV(hWnd, L"wavs\\test2.mp3");
	//Sound2 = LoadWAV(hWnd, L"wavs\\test3.mp3");

	//Sound1 = mciSendCommand(1, MCI_PLAY, MCI_NOTIFY, (DWORD)(LPVOID)&mciPlay);
	//cout << Sound1 << endl;
	//Sleep(2000);

	//Sound2 = mciSendCommand(2, MCI_PLAY, MCI_NOTIFY, (DWORD)(LPVOID)&mciPlay);
	//cout << Sound2 << endl;
	////Sound1 = mciSendCommand(1, MCI_SEEK, MCI_SEEK_TO_START, (DWORD)(LPVOID)NULL);
	//Sound1 = mciSendCommand(1, MCI_PAUSE, NULL, (DWORD)(LPVOID)NULL);
	//cout << Sound1 << endl;

	//Sleep(2000);
	//mciPlay.dwFrom = 100;

	//Sound1 = mciSendCommand(1, MCI_PLAY, MCI_NOTIFY, (DWORD)(LPVOID)&mciPlay);
	//cout << Sound1 << endl;

		case WM_KEYDOWN:
		printf("WM_KEYDOWN: 0x%x\n", wParam);
		break;
	case WM_KEYUP:
		printf("WM_KEYUP: 0x%x\n", wParam);
		break;
	case WM_CHAR:
		printf("WM_CHAR: %c\n", (wchar_t)wParam);
		break;





base
1 2 3
4 5 6
7 8 9

*rotate cw
ans
7 4 1
8 5 2
9 6 3

way
1. trans
1 4 7
2 5 8
3 6 9

2. reverse row
7 4 1
8 5 2
3 6 9

*rotate ccw
ans
3 6 9
2 5 8
1 4 7

way
1. trans
1 4 7
2 5 8
3 6 9
2. reverse col
3 6 9
2 5 8
1 4 7

void Trans(BitmapPack* pack) {
	COLORREF* a = pack->data;
	int w = pack->width, h = pack->height, s = pack->size;
	int i, j, k, l;
	COLORREF** aa = new COLORREF * [h];
	aa[0] = &a[0];
	for (i = 1; i < h; i++) {
		aa[i] = aa[i - 1] + w;
	}

	COLORREF* b = new COLORREF[s];
	COLORREF** bb = new COLORREF * [w];
	bb[0] = &b[0];
	for (i = 1; i < w; i++) {
		bb[i] = bb[i - 1] + h;
	}

	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++) {
			bb[i][j] = aa[j][i];
		}
	}
	pack->data = b;
	delete[] a;
	delete[] aa;
	delete[] bb;
}






















void Run(promise<string>* p) {
	memset(keys, 0x00, sizeof(char) * 128);
	HDC hdc = GetDC(hWnd);
	HDC src = CreateCompatibleDC(hdc);
	SetGame();
	SetSounds();
	//PlayMp3(hWnd, 1);

	int f = 0;
	while (1) {
		if (f % 60 == 0) {
			cout << "frame " << f << endl;
			//PlayMp3(hWnd, 4);
			RotateCW(game->layers->at(1)->objects->at(2)->shapes->at(0));
		}
		f++;
		game->Draw();
		HBITMAP map = CreateBitmap(WIDTH, WIDTH, 1, 8 * 4, (void*)game->board);
		SelectObject(src, map);
		BitBlt(hdc, 0, 0, WIDTH, WIDTH, src, 0, 0, SRCCOPY);
		Sleep(30);
	}

	DeleteDC(src);
	ReleaseDC(hWnd, hdc);
	p->set_value("End");
}

void SetGame() {
	//Set resources
	game = new Game(WIDTH, WIDTH);

	game->AddShape("bmps\\bg.bmp");
	game->AddShape("bmps\\test1.bmp");
	game->AddShape("bmps\\test2.bmp");
	game->AddShape("bmps\\test3.bmp");
	game->AddShape("bmps\\test4.bmp");

	COLORREF block[16]{ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
						0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00000000,
						0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00000000,
						0x00ffffff, 0x00ffffff, 0x00ffffff, 0x00000000 };

	BitmapPack* blockPack = CreateBitmap(block, 16, 4, 4, 16);
	game->AddShape(blockPack);
	//~Set resources

	GLayer* bgLayer = new GLayer(WIDTH, WIDTH);
	game->AddLayer(bgLayer);

	GObject* background = new GObject();
	bgLayer->AddObject(background);
	background->AddShape(0);
	background->width = WIDTH;
	background->height = WIDTH;

	GLayer* objectLayer = new GLayer(WIDTH, WIDTH);
	game->AddLayer(objectLayer);

	GObject* obj1 = new GObject();
	objectLayer->AddObject(obj1);
	obj1->AddShape(1);
	obj1->AddShape(2);
	obj1->width = 60;
	obj1->height = 60;
	obj1->x = 100;
	obj1->y = 100;

	GObject* obj2 = new GObject();
	objectLayer->AddObject(obj2);
	obj2->AddShape(3);
	obj2->AddShape(4);
	obj2->width = 60;
	obj2->height = 60;
	obj2->x = 300;
	obj2->y = 300;

	GObject* obj3 = new GObject();
	objectLayer->AddObject(obj3);
	obj3->AddShape(5);
	obj3->width = 16 * 4;
	obj3->height = 16 * 4;
	obj3->x = 200;
	obj3->y = 200;
	

	vector<pair<int, int>>* action = new vector<pair<int, int>>();
	action->push_back(make_pair(0, 3));
	action->push_back(make_pair(1, 5));
	obj1->actions->push_back(action);
	obj2->actions->push_back(action);
}

void SetSounds() {
	LoadMp3(hWnd, L"mp3s\\1.mp3");
	LoadMp3(hWnd, L"mp3s\\2.mp3");
	LoadMp3(hWnd, L"mp3s\\3.mp3");
	LoadMp3(hWnd, L"mp3s\\4.mp3");
	LoadMp3(hWnd, L"mp3s\\5.mp3");
	LoadMp3(hWnd, L"mp3s\\6.mp3");
	LoadMp3(hWnd, L"mp3s\\7.mp3");
}

void KeyDown(WPARAM wParam) {
	if (keys[wParam] == 0) {
		keys[wParam] = 1;
		printf("Key down 0x%x\n", wParam);
		switch (wParam) {
		case 0x20://space
			break;
		case 0x25://l
			game->layers->at(1)->objects->at(0)->x -= 5;
			break;
		case 0x26://u
			game->layers->at(1)->objects->at(0)->y -= 5;
			break;
		case 0x27://r
			game->layers->at(1)->objects->at(0)->x += 5;
			break;
		case 0x28://d
			game->layers->at(1)->objects->at(0)->y += 5;
			break;
		default:
			break;
		}
	}
	else {
		printf("Key pressing 0x%x\n", wParam);
	}
}

void KeyUp(WPARAM wParam) {
	keys[wParam] = 0;
	printf("Key up 0x%x\n", wParam);
	switch (wParam) {
	case 0x20://space
		break;
	case 0x25://l
		break;
	case 0x26://u
		break;
	case 0x27://r
		break;
	case 0x28://d
		break;
	default:
		break;
	}
}


	c = RED;
	//bs[0] = new BitmapPack(4, 4, 16, new COLORREF[16]{ c, c, x, x, x, c, c, x, x, x, x, x, x, x, x, x });
	bs[0] = CreateBitmap(new COLORREF[16]{ c, c, x, x, x, c, c, x, x, x, x, x, x, x, x, x }, 16, 4, 4, 16);
	c = GREEN;
	//bs[1] = new BitmapPack(4, 4, 16, new COLORREF[16]{ x, c, c, x, c, c, x, x, x, x, x, x, x, x, x, x });
	bs[1] = CreateBitmap(new COLORREF[16]{ x, c, c, x, c, c, x, x, x, x, x, x, x, x, x, x }, 16, 4, 4, 16);
	c = BLUE;
	//bs[2] = new BitmapPack(4, 4, 16, new COLORREF[16]{ c, x, x, x, c, c, c, x, x, x, x, x, x, x, x, x });
	bs[2] = CreateBitmap(new COLORREF[16]{ c, x, x, x, c, c, c, x, x, x, x, x, x, x, x, x }, 16, 4, 4, 16);
	c = YELLOW;
	//bs[3] = new BitmapPack(4, 4, 16, new COLORREF[16]{ c, c, x, x, c, c, x, x, x, x, x, x, x, x, x, x });
	bs[3] = CreateBitmap(new COLORREF[16]{ c, c, x, x, c, c, x, x, x, x, x, x, x, x, x, x }, 16, 4, 4, 16);
	c = CYAN;
	//bs[4] = new BitmapPack(4, 4, 16, new COLORREF[16]{ c, c, c, c, x, x, x, x, x, x, x, x, x, x, x, x });
	bs[4] = CreateBitmap(new COLORREF[16]{ c, c, c, c, x, x, x, x, x, x, x, x, x, x, x, x }, 16, 4, 4, 16);
	c = MAGENTA;
	//bs[5] = new BitmapPack(4, 4, 16, new COLORREF[16]{ x, c, x, x, c, c, c, x, x, x, x, x, x, x, x, x });
	bs[5] = CreateBitmap(new COLORREF[16]{ x, c, x, x, c, c, c, x, x, x, x, x, x, x, x, x }, 16, 4, 4, 16);
	c = ORANGE;
	//bs[6] = new BitmapPack(4, 4, 16, new COLORREF[16]{ x, x, c, x, c, c, c, x, x, x, x, x, x, x, x, x });
	bs[6] = CreateBitmap(new COLORREF[16]{ x, x, c, x, c, c, c, x, x, x, x, x, x, x, x, x }, 16, 4, 4, 16);

//COLORREF** Get2DArray(COLORREF* a, int s, int w, int h) {
//	int i;
//	COLORREF** aa = new COLORREF * [h];
//	aa[0] = &a[0];
//	for (i = 1; i < h; i++) {
//		aa[i] = aa[i - 1] + w;
//	}
//	return aa;
//}

template <typename T> T* Trans(T* a, int s, int w, int h) {
	int i, j;
	T** aa = Get2DArray(pack->data, s, w, h);

	T* b = new COLORREF[s];
	T** bb = Get2DArray(b, s, h, w);

	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++) {
			bb[i][j] = aa[j][i];
		}
	}

	delete[] aa;
	delete[] bb;

	return b;
}

void Trans(BitmapPack* pack) {
	int w = pack->width, h = pack->height, s = pack->size;
	int i, j, k, l;
	COLORREF* a = pack->data;
	COLORREF** aa = Get2DArray(pack->data, pack->size, pack->width, pack->height);

	COLORREF* b = new COLORREF[s];
	COLORREF** bb = Get2DArray(b, pack->size, pack->height, pack->width);

	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++) {
			bb[i][j] = aa[j][i];
		}
	}
	pack->data = b;
	delete[] a;
	delete[] aa;
	delete[] bb;
}

template <typename T> void RevX(T* a, int s, int w, int h) {
	T** aa = Get2DArray(a, s, w, h);
	int i, j, hh = h / 2;
	T t;
	for (i = 0; i < hh; i++) {
		for (j = 0; j < w; j++) {
			t = aa[i][j];
			aa[i][j] = aa[h - i - 1][j];
			aa[h - i - 1][j] = t;
		}
	}
}

void RevX(BitmapPack* pack) {
	int i, j, t, w = pack->width, h = pack->height, s = pack->size;
	COLORREF* a = pack->data;
	COLORREF** aa = Get2DArray(pack->data, pack->size, pack->width, pack->height);
	int hh = h / 2;
	for (i = 0; i < hh; i++) {
		for (j = 0; j < w; j++) {
			t = aa[i][j];
			aa[i][j] = aa[h - i - 1][j];
			aa[h - i - 1][j] = t;
		}
	}
}

template <typename T> void RevY(T* a, int s, int w, int h) {
	T** aa = Get2DArray(a, s, w, h);
	int i, j, ww = w / 2;
	T t;
	for (i = 0; i < ww; i++) {
		for (j = 0; j < h; j++) {
			t = aa[j][i];
			aa[j][i] = aa[j][w - i - 1];
			aa[j][w - i - 1] = t;
		}
	}
}

void RevY(BitmapPack* pack) {
	int i, j, t, w = pack->width, h = pack->height, s = pack->size;
	COLORREF* a = pack->data;
	COLORREF** aa = Get2DArray(pack->data, pack->size, pack->width, pack->height);
	int ww = w / 2;
	for (i = 0; i < ww; i++) {
		for (j = 0; j < h; j++) {
			t = aa[j][i];
			aa[j][i] = aa[j][w - i - 1];
			aa[j][w - i - 1] = t;
		}
	}
}

template <typename T> void RotateCW(T* a, int s, int w, int h) {
	RevY(Trans(a, s, w, h));
}

void RotateCW(BitmapPack* pack) {
	Trans(pack);
	RevY(pack);
}

template <typename T> void RotateCCW(T* a, int s, int w, int h) {
	RevX(Trans(a, s, w, h));
}

void RotateCCW(BitmapPack* pack) {
	Trans(pack);
	RevX(pack);
}

BitmapPack* BpClone(BitmapPack* pack) {
	COLORREF* c = new COLORREF[pack->size];
	memcpy(c, pack->data, pack->size * sizeof(COLORREF*));
	return new BitmapPack(pack->size, pack->width, pack->height, c);
}

	vector<Block*>* blocks = new vector<Block*>();

	for (int i = 0; i < 7; i++) {
		Block* b = tetris->Generate(i);
		b->object->x = 64 + i * 128;
		b->object->y = 256 - 32;
		blocks->push_back(b);
	}

				fs++;
			cout << "frame" << endl;
			f = 0;
		}
		for (int i = 0; i < blocks->size(); i++) {
			blocks->at(i)->Rotate();
		}


				//blocks[i + 7] = new int[16];
		//memcpy(blocks[i + 7], blocks[i], 16 * sizeof(int));
		//RotateCW(blocks[i + 7], 16, 4, 4);

		//blocks[i + 14] = new int[16];
		//memcpy(blocks[i + 14], blocks[i + 7], 16 * sizeof(int));
		//RotateCW(blocks[i + 14], 16, 4, 4);

		//blocks[i + 21] = new int[16];
		//memcpy(blocks[i + 21], blocks[i + 14], 16 * sizeof(int));
		//RotateCW(blocks[i + 21], 16, 4, 4);

		//for (int j = 0; j < 4; j++) {
		//	int t = i + 7 * j;
		//	cout << t << endl;
		//	for (int k = 0; k < 16; k++) {
		//		if (k % 4 == 0) {
		//			cout << endl;
		//		}
		//		cout << blocks[t][k] << ' ';
		//	}
		//	cout << endl;
		//}

			//for (i = 0; i < 7; i++) {
	//	temp = new COLORREF[16];
	//	for (j = 0; j < 16; j++) {
	//		if (blocks[i][j] == 0) {
	//			temp[j] = x;
	//		}
	//		else {
	//			temp[j] = (COLORREF)colors[i];
	//		}
	//	}
	//	bs[i] = CreateBitmap(temp, 16, 4, 4, 16);
	//}

	//int t;
	//for (int i = 0; i < 7; i++) {
	//	for (int j = 1; j < sc[i]; j++) {
	//		t = i + j * 7;
	//		bs[t] = BpClone(bs[i]);
	//		for (int k = 0; k < j; k++) {
	//			RotateCW(bs[t]);
	//		}
	//	}
	//}

	BitmapPack** Tetris::SetBlocks() {
	BitmapPack** bs = new BitmapPack * [7 * 4];
	memset(bs, 0x00, 7 * 4 * sizeof(BitmapPack*));
	COLORREF x = WHITE;
	COLORREF c;
	int i, j, t;
	COLORREF* temp;

	for (i = 0; i < 28; i++) {
		if (blocks[i] != nullptr) {
			t = i % 7;
			temp = new COLORREF[16];
			for (j = 0; j < 16; j++) {
				if (blocks[i][j] == 0) {
					temp[j] = x;
				}
				else {
					temp[j] = (COLORREF)colors[t];
				}
			}
			bs[i] = CreateBitmap(temp, 16, 4, 4, 16);
		}		
	}

	return bs;
}


	//BitmapPack** packs = SetBlocks();
	//for (i = 0; i < 28; i++) {
	//	game->AddShape(packs[i]);
	//}


	#include "stdafx.h"
#include "Game.h"
#include "Tetris.h"

#pragma comment(lib,"winmm.lib")

using namespace std;

#define WIDTH 1024
#define HEIGHT 512

#pragma warning(disable:4996)

static TCHAR szWindowClass[] = _T("DesktopApp");
static TCHAR szTitle[] = _T("GameTestBoard");

static HINSTANCE hInst;
static HINSTANCE hPrevInst;
static LPWSTR lpCmdLn;
static int nCmdS;

HWND hWnd;
Game* game;

Tetris* tetris;

char keys[128];

int wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow);
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void Run(promise<string>* p);

void KeyDown(WPARAM wParam);
void KeyUp(WPARAM wParam);

int main(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)
{	
	hInst = hInstance;
	hPrevInst = hPrevInstance;
	lpCmdLn = lpCmdLine;
	nCmdS = nCmdShow;

	srand(static_cast<unsigned int>(time(NULL)));
	wWinMain(hInst, hPrevInst, lpCmdLn, nCmdS);
}

int wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)
{
	WNDCLASSEX wcex;
	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WndProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(hInstance, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = szWindowClass;
	wcex.hIconSm = LoadIcon(wcex.hInstance, IDI_APPLICATION);

	if (!RegisterClassEx(&wcex))
	{
		MessageBox(NULL, _T("Call to RegisterClassEx failed!"), _T("Windows Desktop Guided Tour"), NULL);
		return 1;
	}

	hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW
		, CW_USEDEFAULT, CW_USEDEFAULT, WIDTH + 64, HEIGHT + 64, NULL, NULL, hInstance, NULL);

	if (!hWnd)
	{
		MessageBox(NULL, _T("Call to CreateWindow failed!"), _T("Windows Desktop Guided Tour"), NULL);
		return 1;
	}

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	promise<string> p;
	future<string> data = p.get_future();
	thread t(Run, &p);

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return (int)msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	HDC hdc;

	switch (message)
	{
	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);
		EndPaint(hWnd, &ps);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);		
		break;

	case WM_KEYDOWN:		
		KeyDown(wParam);
		break;
	case WM_KEYUP:		
		KeyUp(wParam);
		break;

	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
		break;
	}

	return 0;
}

void Run(promise<string>* p) {
	memset(keys, 0x00, sizeof(char) * 128);
	HDC hdc = GetDC(hWnd);
	HDC src = CreateCompatibleDC(hdc);
	tetris = new Tetris(hWnd, WIDTH, HEIGHT);
	tetris->Prepare();

	UINT f = 0;
	while (1) {
		COLORREF* board = tetris->Run(f++);
		if (board != nullptr) {
			SelectObject(src, CreateBitmap(WIDTH, HEIGHT, 1, 8 * 4, board));
			BitBlt(hdc, 0, 0, WIDTH, HEIGHT, src, 0, 0, SRCCOPY);
		}
		else {			
			break;
		}
		Sleep(30);
	}
	DeleteDC(src);
	ReleaseDC(hWnd, hdc);
	p->set_value("End");
}

void KeyDown(WPARAM wParam) {
	if (keys[wParam] == 0) {
		keys[wParam] = 1;
		printf("Key down 0x%x\n", (UINT)wParam);
		tetris->KeyDown(wParam);
	}
	else {
		printf("Key pressing 0x%x\n", (UINT)wParam);
		tetris->KeyPressing(wParam);
	}
}

void KeyUp(WPARAM wParam) {
	keys[wParam] = 0;
	printf("Key up 0x%x\n", (UINT)wParam);
	tetris->KeyUp(wParam);
}


//int Block::Check() {
//	int i, j;
//	for (i = 0; i < h; i++) {
//		for (j = 0; j < w; j++) {
//			if (map[i][j] == -1) {
//				map[i][j] = 0;
//			}
//		}
//	}
//
//	int** block = Get2DArray(shape[cs], 16, 4, 4);
//	int a, b, oc = 0;
//	for (i = 0; i < 4; i++) {
//		for (j = 0; j < 4; j++) {
//			a = i + y;
//			b = j + x;
//			if (block[i][j] == 1) {
//				if (a < 0 || a >= h || b < 0 || b >= w) {
//					oc++;
//				}
//				else if (map[a][b] > 0) {
//					oc++;
//				}
//			}
//		}
//	}
//
//	if (oc == 0) {
//		for (i = 0; i < 4; i++) {
//			for (j = 0; j < 4; j++) {
//				a = i + y;
//				b = j + x;
//				if (block[i][j] == 1) {
//					map[a][b] = -1;
//				}
//			}
//		}
//		//system("CLS");
//		//for (i = 0; i < h; i++) {
//		//	for (j = 0; j < w; j++) {
//		//		if (map[i][j] == -1) {
//		//			cout << 'X' << ' ';
//		//		}
//		//		else {
//		//			cout << map[i][j] << ' ';
//		//		}
//		//	}
//		//	cout << endl;
//		//}
//		//cout << endl;
//
//		delete[] block;
//		return 0;
//	}
//	else {
//
//		delete[] block;
//		return 1;
//	}
//}

	for (i = 0; i < 7; i++) {
		for (j = 1; j <= sc[i]; j++) {
			//blocks[i + 7 * j] = new int[16];
			//memcpy(blocks[i + 7 * j], blocks[i + 7 * (j - 1)], 16 * sizeof(int));
			//RotateCW(blocks[i + 7 * j], 16, 4, 4);
		}
	}

		blocks = new int* [28];
	memset(blocks, 0x00, 28 * sizeof(int*));
	blocks[0] = new int[16]{ 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[7] = new int[16]{ 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };

	blocks[1] = new int[16]{ 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[8] = new int[16]{ 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 };

	blocks[2] = new int[16]{ 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[9] = new int[16]{ 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };
	blocks[16] = new int[16]{ 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[23] = new int[16]{ 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 };

	blocks[3] = new int[16]{ 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	blocks[4] = new int[16]{ 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[11] = new int[16]{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 };

	blocks[5] = new int[16]{ 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[12] = new int[16]{ 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };
	blocks[19] = new int[16]{ 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[26] = new int[16]{ 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 };

	blocks[6] = new int[16]{ 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[13] = new int[16]{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 };
	blocks[20] = new int[16]{ 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	blocks[27] = new int[16]{ 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 };

		//const int** block = Get2DArray(blocks[t], 16, 4, 4);
	//for (i = 0; i < 4; i++) {
	//	a = y + i;
	//	for (j = 0; j < 4; j++) {
	//		b = x + j;
	//		if (block[i][j] == 1) {
	//			if (map[a][b] > 0) {
	//				delete[] block;
	//				return 1;
	//			}
	//		}
	//	}
	//}

	//for (i = 0; i < 4; i++) {
	//	a = y + i;
	//	for (j = 0; j < 4; j++) {
	//		b = x + j;
	//		if (block[i][j] == 1) {
	//			map[a][b] = -1;
	//		}
	//	}
	//}
	//delete[] block;

		//const int** block = Get2DArray(blocks[t], 16, 4, 4);
	//for (i = 0; i < 4; i++) {
	//	a = y + i;
	//	if (a == mh - 1) {
	//		return 1;
	//	}
	//	for (j = 0; j < 4; j++) {
	//		b = x + j;
	//		if (map[a][b + 1] > 0) {
	//			return 1;
	//		}
	//	}
	//}
	//delete[] block;

		for (i = 0; i < 4; i++) {
		a = y + i;
		for (j = 0; j < 4; j++) {
			b = x + j;
			k = i * 4 + j;
			if (block[k] == 1) {
				map[a][b] = 1;
			}
		}
	}

		//BYTE** a = new BYTE * [h];
	//for (i = 0; i < h; i++) {
	//	a[i] = new BYTE[w];
	//	memset(a[i], 0x00, w * sizeof(BYTE));
	//}

	void Tetris::Generate() {
	int i;
	Block* block = new Block(map, w, h);

	GObject* object = new GObject();
	layer->AddObject(object);

	for (i = 0; i < scs[id]; i++) {
		object->AddShape(id + 7 * i);
	}

	object->width = 4 * 16;
	object->height = 4 * 16;
	block->object = object;

	return block;
}

void Block::Next() {
	x = -1;
	y = -1;
	object->x = 512 + 256 - 32;
	object->y = 256 - 32;
}


	//system("CLS");
	//for (int i = 0; i < mh; i++) {
	//	for (int j = 0; j < mw; j++) {
	//		printf("%d ", map[i][j]);
	//	}
	//	printf("\n");
	//}
	//printf("\n");

	void Draw(promise<string>* p) {
	memset(keys, 0x00, sizeof(char) * 128);
	HDC hdc = GetDC(hWnd);
	HDC src = CreateCompatibleDC(hdc);
	tetris = new Tetris(hWnd, WIDTH, HEIGHT);
	tetris->Prepare();

	UINT f = 0;
	while (1) {
		COLORREF* board = tetris->Run(f++);
		if (board != nullptr) {
			SelectObject(src, CreateBitmap(WIDTH, HEIGHT, 1, 8 * 4, board));
			BitBlt(hdc, 0, 0, WIDTH, HEIGHT, src, 0, 0, SRCCOPY);
		}
		Sleep(30);
	}
	DeleteDC(src);
	ReleaseDC(hWnd, hdc);
	p->set_value("End");
}

void Tetris::Update() {
	int i, j, t;

	BitmapPack* downs = game->shapes->at(28);
	int size = downs->size, width = downs->width, height = downs->height;

	COLORREF* mapRef = new COLORREF[w * h];
	memset(mapRef, 0x00, w * h * sizeof(COLORREF));
	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++) {
			if (map[i][j] > 1) {
				mapRef[i * w + j] = colors[map[i][j] - 2];
			}
		}
	}
	BitmapPack* mapRes = CreateBitmap(mapRef, w * h, w, h, 16);
	delete[] downs->data;
	downs->data = mapRes->data;
	delete[] mapRef;
}















BYTE Block::CLeft(BYTE z) {
	if (x <= z - 1) {
		return 1;
	}
	int i, j, a, b;
	const BYTE* block = blocks[cs * 7 + id];
	for (i = 0; i < Ht(); i++) {
		a = y + i;
		for (j = 0; j < Wt(); j++) {
			if (block[i * 4 + j] == 1) {
				b = x + j;
				if (tMap[a][b - 1] > 1) {
					return 1;
				}
				break;
			}
		}
	}
	return 0;
}

BYTE Block::CRight(BYTE z) {
	if (x + Wt() >= tmw - z + 1) {
		return 1;
	}
	int i, j, a, b;
	const BYTE* block = blocks[cs * 7 + id];
	for (i = 0; i < Ht(); i++) {
		a = y + i;
		for (j = Wt() - 1; j >= 0; j--) {
			if (block[i * 4 + j] == 1) {
				b = x + j;
				if (tMap[a][b + 1] > 1) {
					return 1;
				}
				break;
			}
		}
	}
	return 0;
}

BYTE Block::CDown(BYTE z) {
	int i, j, k, a, b;
	const BYTE* block = blocks[cs * 7 + id];
	for (i = 0; i < 4; i++) {
		if (y + Ht() >= tmh - z + 1) {
			return 1;
		}
		a = y + i;
		for (j = 0; j < 4; j++) {
			b = x + j;
			if (block[i * 4 + j] == 1 && tMap[a + 1][b] > 1) {
				return 1;
			}
		}
	}
	return 0;
}

BYTE Block::Left() {
	//if (x <= 0) {
	//	return 1;
	//}
	//int i, j, a, b;
	//const BYTE* block = blocks[cs * 7 + id];
	//for (i = 0; i < Ht(); i++) {
	//	a = y + i;
	//	for (j = 0; j < Wt(); j++) {
	//		if (block[i * 4 + j] == 1) {
	//			b = x + j;
	//			if (tMap[a][b - 1] > 1) {
	//				return 1;
	//			}
	//			break;
	//		}
	//	}
	//}
	if (CLeft() == 0) {
		return 1;
	}
	x--;
	Update();
	object->x -= 16;
	return 0;
}

BYTE Block::Right() {
	//if (x + Wt() >= tmw) {
	//	return 1;
	//}
	//int i, j, a, b;
	//const BYTE* block = blocks[cs * 7 + id];
	//for (i = 0; i < Ht(); i++) {
	//	a = y + i;
	//	for (j = Wt() - 1; j >= 0; j--) {
	//		if (block[i * 4 + j] == 1) {
	//			b = x + j;
	//			if (tMap[a][b + 1] > 1) {
	//				return 1;
	//			}
	//			break;
	//		}
	//	}
	//}
	if (CRight() == 0) {
		return 1;
	}
	x++;
	Update();
	object->x += 16;
	return 0;
}

			if (j == tmh - 1 || tMap[j][i] > 1) {
				a = j == tmh - 1 ? j : j - 1;
				for (k = tmh - 1; k >= 0; k--) {
					if (tMap[k][i] == 1) {
						b = k + 1;
						break;
					}
				}
				break;
			}






BYTE Block::Drop() {
	int i, j, k, a, b, c = 0, d = tmh;
	const BYTE* block = blocks[cs * 7 + id];

	for (i = x; i < x + Wt(); i++) {
		a = 0;
		b = 0;
		for (j = 0; j < tmh; j++) {
			if (j == tmh - 1 || tMap[j][i] > 1) {
				a = j == tmh - 1 ? j : j - 1;
				for (k = tmh - 1; k >= 0; k--) {
					if (tMap[k][i] == 1) {
						b = k + 1;
						break;
					}
				}
				break;
			}
		}
		c = a - b + 1;
		if (c > 0 && c < d) {
			d = c;
		}
	}

	if (d <= 0 || d >= tmh || y + d >= tmh) {
		return 1;
	}
	else {
		y += d;
		Update();
		object->y += 16 * d;
		return 0;
	}
}